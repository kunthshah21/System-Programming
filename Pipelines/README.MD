## CONTRIBUTORS: 
# Kunth Shah
# Varsha Gunturu 

# Interprocess Communication with Pipes - README

## Overview

This C program, `my_ipc.c`, showcases interprocess communication using pipes. It allows two processes to exchange data, with one process acting as a data generator and the other as a data consumer.

## Functionality

The program takes two command-line arguments:

1. The generator command: This is the command that produces the data to be consumed.
2. The consumer command: This is the command that consumes the data produced by the generator.

The program then creates a pipe to connect the standard output of the generator process to the standard input of the consumer process. This pipe enables data generated by the generator to be transmitted to the consumer for processing.

## Design Choices

### Pipe Creation

A pipe is created using the `pipe()` system call. This pipe is a unidirectional communication channel that allows data to flow from the generator process to the consumer process.

### Forking

After creating the pipe, the program forks a child process using the `fork()` system call. This child process will execute the generator command, while the parent process will execute the consumer command.

### Closing Unused File Descriptors

In the child process (generator), the read end of the pipe is closed (`close(pipefd[0])`) because it does not need to read from the pipe. The standard output (`STDOUT_FILENO`) is then redirected to the write end of the pipe (`dup2(pipefd[1], STDOUT_FILENO)`).

In the parent process (consumer), the write end of the pipe is closed (`close(pipefd[1])`) because it does not need to write to the pipe. The standard input (`STDIN_FILENO`) is redirected to the read end of the pipe (`dup2(pipefd[0], STDIN_FILENO)`).

### Execution of Commands

The child process (generator) executes the generator command using `execlp()`, which replaces the current process image with the specified command. Similarly, the parent process (consumer) executes the consumer command using `execlp()`. This allows the program to execute external commands without spawning additional processes.

### Error Handling

Error handling is implemented throughout the program to detect and handle potential failures. If an error occurs during pipe creation, forking, or command execution, an error message is printed, and the program exits with a failure status. This is for obvious reasons printed with the help of the `perror()` command.
